File = _{ SOI ~ NEWLINE* ~ (Statement ~ NEWLINE+)* ~ Statement? ~ EOI }
Statement = {
	AssignStatement
    | SuperExpression
}
AssignStatement = { PatternAssignment | VariableAssignment | PropertiesAssignment }

VariableAssignment = { Variable ~ "=" ~ SuperExpression }
PropertiesAssignment = { SuperExpression ~ Properties }
SuperExpression = {  MethodCall | Expression }
MethodCall = { Expression ~ FunctionExpression+ }
Expression = { 
    PropertyGetter
    | Boolean
    | FunctionExpression
    | Identifier 
    | Variable 
    | PatternString 
    | Number 
    | String 
    | PatternSlot 
    | Track 
    | Mixer
    | Properties
    | Array }
FunctionExpression = { FunctionCall | FunctionListCall }
FunctionListCall = { "[" ~ NEWLINE* ~ FunctionExpression ~ NEWLINE* ~ ("," ~ NEWLINE* ~ FunctionExpression ~ NEWLINE*)* ~ "]" }
FunctionCall = { Identifier | "(" ~ NEWLINE* ~ Identifier ~ NEWLINE* ~ (Expression ~ NEWLINE*)+ ~ ")" }
Boolean = { "true" | "false" }
PatternSlot = ${ Track ~ "." ~ UnsignedInt }
Track = ${ Mixer ~ UnsignedInt }
Mixer = { "$" }
Array = { "[" ~ NEWLINE* ~ ArrayInner ~ NEWLINE* ~ ("," ~ NEWLINE* ~ ArrayInner ~ NEWLINE*)* ~ "]" }
ArrayInner = _{ SuperExpression }
PropertyGetter = { (Variable 
    | PatternString 
    | PatternSlot 
    | Track 
    | Mixer) ~ NEWLINE* ~ ("." ~ NEWLINE* ~ Identifier ~ NEWLINE*)+ }
Properties = { "{" ~ NEWLINE* ~ KvPair ~ NEWLINE* ~ ("," ~ NEWLINE* ~ KvPair)* ~ NEWLINE* ~ "}" }
KvPair = { NEWLINE* ~ Identifier ~ NEWLINE* ~ ":" ~ NEWLINE* ~ (
    SuperExpression
    | PatternExpression) ~ NEWLINE* }
Variable = ${ ":" ~ Identifier }
String = ${ "\"" ~ StringInner ~ "\"" }
StringInner = @{ Char* }
Char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
Identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
Number = @{ "-"? ~ UnsignedFloat }
UnsignedFloat = @{ UnsignedInt
    ~ ("." ~ ASCII_DIGIT*)?
    ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}
UnsignedInt = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
WHITESPACE = _{ " " | "\t" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

// Patterns (meta)language

PatternAssignment = { PatternSlot ~ PatternSuperExpression }
PatternSuperExpression = { PatternExpressionList | PatternExpression }
PatternExpressionList = { PatternExpression ~ NEWLINE* ~ ("," ~ NEWLINE* ~ PatternExpression)+ }
PatternExpression = { Pattern ~ FunctionExpression? ~ ("=>" ~ FunctionExpression*)? ~ Properties? }
Pattern = { "|" ~ Event* ~  "|" }
PatternString = { "'" ~ Event+ ~ "'" }
Event = _{ Chord | Group | ParenthesisedEvent }
ParenthesisedEvent = { "(" ~ Event+  ~ ")" ~ EventMethod* }
Chord = { "[" ~ (Group | ParenthesisedEvent)+ ~ "]" }
Group = ${ PatternSymbol+ }
PatternSymbol = { 
    EventMethod 
    | Octave 
    | Alteration
    | Pitch
    | Pause
    | PatternInput
    | Modulation }
Pitch = { ASCII_DIGIT | 'a'..'f' }
Pause = { "r" }
PatternInput = { "%" }
Octave = { "o" | "O" }
Alteration = { "+" | "-" }
EventMethod = { "_" | "." | "*" | ":" }
Modulation = { "p" | "F" | "<" | ">" | LiteralModulation }
LiteralModulation = { ("{" ~ WHITESPACE* ~ Number ~ WHITESPACE* ~ "}") }


