program = _{ SOI ~ NEWLINE* ~ (stmt ~ NEWLINE+) * ~ stmt? ~ EOI }
stmt = {
	assgn_stmt
    | method_call
    | func_expr
}
assgn_stmt = { pattern_assgmt | variable_assgmt | properties_assgmt }

variable_assgmt = { variable ~ "=" ~ (expression | method_call) }
properties_assgmt = { (expression | method_call) ~ properties }
method_call = { expression ~ func_expr+ }
func_expr = { func_call | func_list_call }
func_list_call = { "[" ~ NEWLINE* ~ func_expr ~ NEWLINE* ~ ("," ~ NEWLINE* ~ func_expr ~ NEWLINE*)* ~ "]" }
func_call = { (property_getter | identifier | variable) 
    | "(" ~ NEWLINE* ~ identifier ~ NEWLINE* ~ (expression ~ NEWLINE*)+ ~ ")" }
expression = _{ 
    property_getter
    | boolean
    | identifier 
    | variable 
    | pattern_string 
    | number 
    | string 
    | pattern_slot 
    | track 
    | mixer
    | properties
    | array
    | func_expr }
boolean = { "true" | "false" }
pattern_slot = @{ track ~ "." ~ unsigned_int }
track = @{ mixer ~ unsigned_int }
mixer = { "$" }
array = { "[" ~ NEWLINE* ~ array_inner ~ NEWLINE* ~ ("," ~ NEWLINE* ~ array_inner ~ NEWLINE*)* ~ "]" }
array_inner = _{ expression | method_call }
property_getter = { (identifier 
    | variable 
    | pattern_string 
    | pattern_slot 
    | track 
    | mixer) ~ NEWLINE* ~ ("." ~ NEWLINE* ~ identifier ~ NEWLINE*)+ }
properties = { "{" ~ NEWLINE* ~ kv_pair ~ NEWLINE* ~ ("," ~ NEWLINE* ~ kv_pair)* ~ NEWLINE* ~ "}" }
kv_pair = { NEWLINE* ~ identifier ~ NEWLINE* ~ ":" ~ NEWLINE* ~ (
    method_call 
    | expression
    | pattern_expr
    | properties) ~ NEWLINE* }
variable = @{ ":" ~ identifier }
string = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
identifier = @{ ASCII_ALPHA+ ~ (ASCII_ALPHANUMERIC | "_")* }
number = @{ "-"? ~ unsigned_float }
unsigned_float = @{ unsigned_int
    ~ ("." ~ ASCII_DIGIT*)?
    ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}
unsigned_int = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
WHITESPACE = _{ " " | "\t" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

// Patterns (meta)language

pattern_assgmt = { pattern_slot ~ (pattern_expr_list | pattern_expr) }
pattern_expr_list = { pattern_expr ~ NEWLINE* ~ ("," ~ NEWLINE* ~ pattern_expr)+ }
pattern_expr = { pattern ~ func_expr? ~ ("=>" ~ func_expr*)? ~ properties? }
pattern = { "|" ~ pattern_inner* ~  "|" }
pattern_string = { "'" ~ pattern_inner+ ~ "'" }
pattern_inner = _{ chord | symbol_group | parenthesised_event }
parenthesised_event = { "(" ~ (symbol_group | chord | parenthesised_event)+  ~ ")" ~ event_method* }
chord = { "[" ~ (symbol_group | parenthesised_event)+ ~ "]" }
symbol_group = @{ pattern_symbol+ }
pattern_symbol = { 
    event_method 
    | octave 
    | alteration
    | pitch
    | pause
    | pattern_input
    | modulation }
pitch = { ASCII_DIGIT | 'a'..'f' }
pause = { "r" }
pattern_input = { "%" }
octave = { "o" | "O" }
alteration = { "+" | "-" }
event_method = { "_" | "." | "*" | ":" }
modulation = { "p" | "F" | "<" | ">" | literal_modulation }
literal_modulation = { ("{" ~ WHITESPACE* ~ number ~ WHITESPACE* ~ "}") }
